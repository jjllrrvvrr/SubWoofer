<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SubWoofer v8 üê∂</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            text-align: center; 
            padding: 20px; 
            background: #000; 
            color: #fff; 
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Compteur */
        #timer { 
            font-size: 3.5rem; 
            font-weight: 700; 
            font-variant-numeric: tabular-nums; 
            color: #ff9f0a;
            margin-top: 10px;
            text-shadow: 0 0 20px rgba(255, 159, 10, 0.3);
        }
        .timer-label { font-size: 0.75rem; color: #666; text-transform: uppercase; margin-bottom: 20px; letter-spacing: 1px;}

        /* Status Badge */
        #status-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 800;
            text-transform: uppercase;
            background: #2c2c2e;
            color: #888;
            margin-bottom: 15px;
            border: 1px solid #333;
        }
        .status-rec { background: #ff3b30 !important; color: white !important; box-shadow: 0 0 15px #ff3b30; animation: pulse 1s infinite; border-color: #ff3b30 !important;}
        .status-wait { background: #30d158 !important; color: #000 !important; border-color: #30d158 !important;}
        
        @keyframes pulse { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.8; } 100% { transform: scale(1); opacity: 1; } }

        /* Visualizer */
        .vis-container {
            position: relative;
            height: 120px;
            background: #1c1c1e;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid #333;
            margin-bottom: 15px;
            box-shadow: inset 0 0 20px #000;
        }
        canvas { width: 100%; height: 100%; }
        
        #threshold-line {
            position: absolute;
            left: 0; right: 0;
            height: 2px;
            background-color: #0a84ff;
            bottom: 20%; 
            pointer-events: none;
            box-shadow: 0 0 8px #0a84ff;
            z-index: 10;
            transition: bottom 0.1s ease-out;
        }

        /* Settings Card */
        .card {
            background: #1c1c1e;
            padding: 15px;
            border-radius: 16px;
            margin-bottom: 20px;
            border: 1px solid #333;
            text-align: left;
        }
        
        /* Filter Toggle */
        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #333;
        }
        .toggle-label { font-size: 0.9rem; font-weight: 600; }
        .toggle-sub { font-size: 0.7rem; color: #666; display: block; margin-top: 2px; }

        .switch-btn {
            background: #3a3a3c; color: #888; border: none; padding: 8px 16px;
            border-radius: 8px; font-size: 0.8rem; font-weight: bold; cursor: pointer;
            transition: all 0.3s ease;
        }
        .switch-btn.active { background: #0a84ff; color: white; box-shadow: 0 0 10px rgba(10, 132, 255, 0.4); }

        /* Slider */
        .slider-header { display: flex; justify-content: space-between; font-size: 0.8rem; color: #aaa; margin-bottom: 5px; }
        .slider-value { color: #0a84ff; font-weight: bold; }
        input[type=range] { width: 100%; height: 40px; accent-color: #0a84ff; cursor: pointer; }

        /* Buttons */
        .controls { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
        
        button.main-btn { 
            font-size: 1rem; padding: 18px; border-radius: 14px; border: none; 
            font-weight: 700; color: white; cursor: pointer; text-transform: uppercase;
            transition: transform 0.1s;
        }
        button.main-btn:active { transform: scale(0.96); }
        
        .btn-start { background: #30d158; color: #000; box-shadow: 0 4px 15px rgba(48, 209, 88, 0.3); }
        .btn-stop { background: #ff3b30; color: #fff; }
        .hidden { display: none; }

    </style>
</head>
<body>

    <div id="status-badge">Pr√™t</div>
    
    <div id="timer">00:00:00</div>
    <div class="timer-label">Dur√©e totale enregistr√©e</div>

    <div class="vis-container">
        <canvas id="visualizer"></canvas>
        <div id="threshold-line"></div>
    </div>

    <div class="card">
        <div class="toggle-row">
            <div>
                <span class="toggle-label">üîç Filtre "Aboiements"</span>
                <span class="toggle-sub">Ignore < 300Hz (bruit sourd) et > 3kHz (vent)</span>
            </div>
            <button id="btn-filter" class="switch-btn active" onclick="toggleFilter()">ACTIV√â</button>
        </div>

        <div class="slider-header">
            <span>Sensibilit√© (Seuil)</span>
            <span id="slider-val" class="slider-value">20</span>
        </div>
        <input type="range" id="slider" min="5" max="100" value="20" oninput="updateThresholdUI()">
    </div>

    <div class="controls">
        <button id="btn-start" class="main-btn btn-start" onclick="startApp()">‚ñ∂ D√©marrer Surveillance</button>
        <button id="btn-stop" class="main-btn btn-stop hidden" onclick="finishAndSave()">‚èπ Finir et T√©l√©charger</button>
    </div>

    <script>
        // --- PARAM√àTRES ---
        const SILENCE_DELAY = 1500; // Ms de silence avant mise en pause
        const LOW_FREQ = 300; 
        const HIGH_FREQ = 3000;
        
        // --- GLOBAL VARIABLES ---
        let audioCtx, analyser, microphone, mediaRecorder;
        let chunks = []; 
        
        let isSystemActive = false;
        let isRecordingState = false; // true = √ßa enregistre, false = c'est en pause
        let isFilterOn = true;
        
        let lastNoiseTime = 0;
        let totalDuration = 0; // Dur√©e r√©elle d'enregistrement
        let startTime = 0; // Pour calculer le delta temps
        let animationId;

        // DOM Elements
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const timerEl = document.getElementById('timer');
        const badge = document.getElementById('status-badge');
        const slider = document.getElementById('slider');
        const filterBtn = document.getElementById('btn-filter');
        const line = document.getElementById('threshold-line');

        async function startApp() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Audio Init
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.3;

                // Cr√©ation Filtres
                const filterHigh = audioCtx.createBiquadFilter();
                filterHigh.type = "highpass";
                filterHigh.frequency.value = isFilterOn ? LOW_FREQ : 0;

                const filterLow = audioCtx.createBiquadFilter();
                filterLow.type = "lowpass";
                filterLow.frequency.value = isFilterOn ? HIGH_FREQ : 22000;
                
                // Connexions pour l'analyse visuelle
                microphone = audioCtx.createMediaStreamSource(stream);
                microphone.connect(filterHigh);
                filterHigh.connect(filterLow);
                filterLow.connect(analyser);

                // Initialisation de l'enregistreur
                setupRecorder(stream);
                
                // On lance l'enregistreur tout de suite...
                mediaRecorder.start();
                // ... mais on le met en pause imm√©diatement !
                mediaRecorder.pause();

                isSystemActive = true;
                updateUI('running');
                loop();

            } catch (e) {
                alert("Erreur micro : " + e.message);
            }
        }

        function setupRecorder(stream) {
            let options = { mimeType: 'audio/webm' };
            if (!MediaRecorder.isTypeSupported('audio/webm')) {
                options = { mimeType: 'audio/mp4' }; // Fallback Safari
            }
            
            mediaRecorder = new MediaRecorder(stream, options);
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            mediaRecorder.onpause = () => {
                isRecordingState = false;
                badge.innerText = "En veille (Silence)";
                badge.className = "status-wait";
            };

            mediaRecorder.onresume = () => {
                isRecordingState = true;
                badge.innerText = "ENREGISTREMENT...";
                badge.className = "status-rec";
            };
        }

        function loop() {
            if (!isSystemActive) return;
            animationId = requestAnimationFrame(loop);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            // Calcul volume moyen
            let sum = 0;
            for(let i=0; i<bufferLength; i++) sum += dataArray[i];
            let volume = sum / bufferLength;

            let threshold = parseInt(slider.value);
            drawVisualizer(volume, threshold);

            let now = Date.now();

            if (volume > threshold) {
                // BRUIT D√âTECT√â
                lastNoiseTime = now;
                
                if (mediaRecorder.state === "paused") {
                    mediaRecorder.resume();
                    startTime = now; // On note quand √ßa a repris
                } else {
                    // C'est d√©j√† en cours, on ajoute le temps √©coul√© depuis la derni√®re frame
                    // C'est une estimation pour l'affichage, le vrai temps sera celui du fichier
                    if (isRecordingState) {
                       totalDuration += 16.66; // approx 60fps
                       timerEl.innerText = formatTime(totalDuration); 
                    }
                }

            } else {
                // SILENCE
                if (mediaRecorder.state === "recording") {
                    let timeSinceNoise = now - lastNoiseTime;
                    
                    if (timeSinceNoise < SILENCE_DELAY) {
                        // On continue d'enregistrer le "blanc" post-bruit
                        totalDuration += 16.66;
                        timerEl.innerText = formatTime(totalDuration); 
                    } else {
                        // Trop long silence -> PAUSE
                        mediaRecorder.pause();
                    }
                }
            }
        }

        function finishAndSave() {
            isSystemActive = false;
            cancelAnimationFrame(animationId);

            if (mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            // On attend que le fichier soit finalis√©
            mediaRecorder.onstop = () => {
                if (chunks.length === 0) {
                    alert("Aucun enregistrement (pas assez de bruit).");
                    location.reload();
                    return;
                }

                const blob = new Blob(chunks, { type: mediaRecorder.mimeType });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                
                let date = new Date();
                let timeStr = `${pad(date.getHours())}h${pad(date.getMinutes())}`;
                let durationStr = formatTime(totalDuration).replace(/:/g,'-');
                
                a.download = `Preuve_Aboiements_${timeStr}_Total-${durationStr}.mp4`;
                
                document.body.appendChild(a);
                a.click();
                
                badge.innerText = "T√©l√©charg√© !";
                setTimeout(() => { 
                    if(confirm("Fichier sauvegard√©. Relancer ?")) location.reload(); 
                }, 1000);
            };
        }

        // --- UI & Helpers ---
        function toggleFilter() {
            isFilterOn = !isFilterOn;
            filterBtn.classList.toggle("active");
            filterBtn.innerText = isFilterOn ? "ACTIV√â" : "D√âSACTIV√â";
            
            // Re-appliquer les filtres si possible
            // Note: avec cette m√©thode simple, le filtre est appliqu√© √† l'analyseur
            // mais l'enregistrement prend le flux "brut" du micro pour la qualit√©.
            // Si vous voulez enregistrer le son filtr√©, c'est plus complexe, 
            // mais pour l'analyse c'est parfait.
        }

        function updateThresholdUI() {
            let val = parseInt(slider.value);
            document.getElementById('slider-val').innerText = val;
            let pct = (val / 120) * 100; 
            line.style.bottom = pct + "%";
        }

        function drawVisualizer(vol, thresh) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let barHeight = (vol / 120) * canvas.height; 
            
            if (vol > thresh) ctx.fillStyle = '#ff3b30'; 
            else ctx.fillStyle = '#30d158'; 
            
            ctx.fillRect(0, canvas.height - barHeight, canvas.width, barHeight);
        }

        function updateUI(state) {
            document.getElementById('btn-start').classList.add('hidden');
            document.getElementById('btn-stop').classList.remove('hidden');
        }

        function formatTime(ms) {
            let s = Math.floor(ms / 1000);
            let m = Math.floor(s / 60);
            let h = Math.floor(m / 60);
            s = s % 60; m = m % 60;
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }
        function pad(n) { return n.toString().padStart(2, '0'); }

        updateThresholdUI();
    </script>
</body>
</html>
