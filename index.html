<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubWoofer üê∂</title>
    <style>
        /* Design sombre pour √©conomiser la batterie */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            text-align: center; 
            padding: 20px; 
            background: #000000; 
            color: #fff; 
            touch-action: manipulation; /* Emp√™che le zoom double-tap */
        }
        
        h1 { font-size: 1.8rem; margin-bottom: 5px; }
        .subtitle { color: #666; font-size: 0.9rem; margin-bottom: 25px; }

        /* Le compteur g√©ant */
        #timer { 
            font-size: 4.5rem; 
            font-weight: 200; 
            font-variant-numeric: tabular-nums; 
            margin: 20px 0;
            color: #fff;
        }

        /* Indicateur d'√©tat (REC / PAUSE) */
        #status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            background: #333;
            color: #888;
            margin-bottom: 20px;
        }
        .status-rec { background: #ff3b30 !important; color: white !important; animation: pulse 1s infinite; }
        .status-listen { background: #30d158 !important; color: white !important; }
        .status-pause { background: #ff9f0a !important; color: black !important; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* Visualiseur Audio */
        canvas { 
            width: 100%; 
            height: 100px; 
            background: #1c1c1e; 
            border-radius: 10px; 
            border: 1px solid #333;
        }

        /* Slider de r√©glage */
        .slider-box { margin: 20px 0; padding: 15px; background: #1c1c1e; border-radius: 12px; }
        input[type=range] { width: 100%; accent-color: #0a84ff; height: 30px; }
        .slider-info { display: flex; justify-content: space-between; font-size: 0.75rem; color: #888; margin-top: 5px; }

        /* Zone des Boutons */
        .controls { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            margin-top: 30px; 
        }

        button { 
            font-size: 1.2rem; 
            padding: 20px; 
            border-radius: 16px; 
            border: none; 
            font-weight: 600; 
            cursor: pointer; 
            width: 100%;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }

        /* Couleurs des boutons */
        .btn-start { background: #30d158; color: white; }
        .btn-pause { background: #ff9f0a; color: black; }
        .btn-resume { background: #30d158; color: white; }
        .btn-stop { background: #ff3b30; color: white; }
        
        /* Utilitaires */
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <h1>SubWoofer</h1>
    <p class="subtitle">Enregistreur intelligent d'aboiements</p>

    <div id="status-badge">Pr√™t</div>
    <div id="timer">00:00:00</div>

    <canvas id="visualizer"></canvas>

    <div class="slider-box">
        <div class="slider-info" style="margin-bottom:5px; font-size:0.9rem; color:white;">Seuil de d√©clenchement (Ligne Bleue)</div>
        <input type="range" id="threshold" min="0" max="255" value="40">
        <div class="slider-info">
            <span>Sensible (bruits faibles)</span>
            <span>Moins sensible (bruits forts)</span>
        </div>
    </div>

    <div class="controls">
        <!-- √âtat 1 : Au d√©but -->
        <button id="btn-start" class="btn-start" onclick="startSystem()">‚ñ∂ D√âMARRER</button>

        <!-- √âtat 2 : Pendant l'enregistrement -->
        <div id="active-controls" class="hidden" style="display:flex; gap:10px;">
            <button id="btn-pause" class="btn-pause" style="flex:1" onclick="togglePause()">‚è∏ PAUSE</button>
            <button id="btn-stop" class="btn-stop" style="flex:1" onclick="stopAndSave()">‚èπ STOP & SAVE</button>
        </div>
        
        <!-- Lien de t√©l√©chargement cach√© -->
        <a id="download-link" style="display:none"></a>
    </div>

    <script>
        // --- VARIABLES ---
        let audioCtx, analyser, source, mediaRecorder;
        let chunks = [];
        let isRunning = false;
        let isPaused = false;
        let lastNoiseTime = 0;
        let accumulatedTime = 0; // Temps total d'aboiement en ms
        let animationId;
        
        // Configuration
        const COOLDOWN = 2000; // 2 secondes de marge apr√®s le bruit
        
        // √âl√©ments DOM
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const timerEl = document.getElementById('timer');
        const badgeEl = document.getElementById('status-badge');
        const sliderEl = document.getElementById('threshold');
        
        const btnStart = document.getElementById('btn-start');
        const activeControls = document.getElementById('active-controls');
        const btnPause = document.getElementById('btn-pause');

        // --- FONCTIONS PRINCIPALES ---

        async function startSystem() {
            try {
                // 1. Init Audio
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);

                // 2. Init Recorder
                // On essaie d'utiliser un format compatible iPhone
                let options = { mimeType: 'audio/mp4' };
                if (!MediaRecorder.isTypeSupported('audio/mp4')) {
                    options = { mimeType: 'audio/webm' }; // Fallback Android/PC
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
                mediaRecorder.start(); 
                mediaRecorder.pause(); // On commence en pause (attente de bruit)

                // 3. UI
                isRunning = true;
                isPaused = false;
                btnStart.classList.add('hidden');
                activeControls.classList.remove('hidden');
                activeControls.style.display = 'flex';
                
                visualize();
                
            } catch (err) {
                alert("Erreur micro : V√©rifiez les r√©glages Safari.\n" + err);
            }
        }

        function togglePause() {
            if (!isPaused) {
                // Mettre en PAUSE MANUELLE
                isPaused = true;
                btnPause.innerText = "‚ñ∂ REPRENDRE";
                btnPause.className = "btn-resume"; // Devient vert
                badgeEl.innerText = "EN PAUSE";
                badgeEl.className = "status-pause";
                
                if (mediaRecorder.state === "recording") {
                    mediaRecorder.pause();
                }
            } else {
                // Reprendre
                isPaused = false;
                btnPause.innerText = "‚è∏ PAUSE";
                btnPause.className = "btn-pause"; // Devient jaune
                // On laisse la boucle visualize g√©rer l'√©tat du recorder
            }
        }

        function stopAndSave() {
            isRunning = false;
            cancelAnimationFrame(animationId);
            
            // Arr√™t final
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
                
                // Attendre un peu que le dernier chunk soit trait√©
                setTimeout(() => {
                    const blob = new Blob(chunks, { type: 'audio/mp4' }); // ou webm
                    const url = URL.createObjectURL(blob);
                    
                    // T√©l√©chargement
                    const a = document.getElementById('download-link');
                    a.href = url;
                    // Nom du fichier avec date
                    const date = new Date();
                    const fileName = `SubWoofer_${date.getHours()}h${date.getMinutes()}.mp4`;
                    a.download = fileName;
                    a.click();
                    
                    if(confirm("Fichier t√©l√©charg√© ! Voulez-vous remettre √† z√©ro ?")) {
                        location.reload();
                    }
                }, 100);
            }
        }

        // --- BOUCLE DE D√âTECTION ---
        function visualize() {
            if (!isRunning) return;
            animationId = requestAnimationFrame(visualize);

            // 1. Si on est en pause manuelle, on dessine juste un √©cran noir et on sort
            if (isPaused) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }

            // 2. Analyse Audio
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Calcul Volume Moyen
            let sum = 0;
            for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
            let volume = sum / bufferLength;

            // R√©cup√®re le seuil du slider
            let threshold = parseInt(sliderEl.value);

            // 3. Dessin
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Barre de volume
            let barHeight = (volume / 255) * canvas.height;
            // Couleur rouge si > seuil, vert sinon
            ctx.fillStyle = volume > threshold ? '#ff3b30' : '#30d158';
            ctx.fillRect(0, canvas.height - barHeight, canvas.width, barHeight);

            // Ligne de seuil (Bleue)
            let thY = canvas.height - (threshold / 255) * canvas.height;
            ctx.beginPath();
            ctx.strokeStyle = '#0a84ff';
            ctx.lineWidth = 3;
            ctx.moveTo(0, thY);
            ctx.lineTo(canvas.width, thY);
            ctx.stroke();

            // 4. Logique d'enregistrement "Intelligente"
            const now = Date.now();

            if (volume > threshold) {
                // BRUIT D√âTECT√â
                lastNoiseTime = now;
                
                if (mediaRecorder.state === "paused") {
                    mediaRecorder.resume();
                }
                
                badgeEl.innerText = "üî¥ ENREGISTREMENT";
                badgeEl.className = "status-rec";
                
                // Compteur + temps r√©el (approx 60fps -> 16ms)
                accumulatedTime += 16.66;
                timerEl.innerText = formatTime(accumulatedTime);

            } else {
                // SILENCE
                // Est-ce qu'on est encore dans la "queue" de 2 secondes ?
                if (now - lastNoiseTime < COOLDOWN) {
                    // Oui : on continue d'enregistrer le silence de s√©curit√©
                    if (mediaRecorder.state === "paused") {
                        mediaRecorder.resume(); 
                    }
                    badgeEl.innerText = "üî¥ Fin d'aboiement...";
                    badgeEl.className = "status-rec";
                    
                    // On compte aussi ce temps de s√©curit√© dans le timer car √ßa enregistre
                    accumulatedTime += 16.66;
                    timerEl.innerText = formatTime(accumulatedTime);
                    
                } else {
                    // Non : Vrai silence prolong√© -> Pause recorder
                    if (mediaRecorder.state === "recording") {
                        mediaRecorder.pause();
                    }
                    badgeEl.innerText = "üü¢ En √©coute (Veille)";
                    badgeEl.className = "status-listen";
                }
            }
        }

        // Formatage MM:SS:ms
        function formatTime(ms) {
            let s = Math.floor(ms / 1000);
            let m = Math.floor(s / 60);
            let h = Math.floor(m / 60);
            
            s = s % 60;
            m = m % 60;
            
            // Affiche seulement H:M:S pour faire propre
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }
        function pad(n) { return n.toString().padStart(2, '0'); }
    </script>
</body>
</html>
