<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Détecteur d'Aboiements</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; text-align: center; padding: 20px; background: #f0f0f5; color: #333; }
        h2 { margin-bottom: 10px; }
        .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 20px; }
        
        /* Compteur */
        #timer { font-size: 3rem; font-weight: bold; font-variant-numeric: tabular-nums; color: #ff3b30; }
        .label { font-size: 0.9rem; color: #666; text-transform: uppercase; letter-spacing: 1px; }

        /* Visuel Audio */
        canvas { width: 100%; height: 100px; background: #eee; border-radius: 8px; margin: 15px 0; }
        
        /* Contrôles */
        input[type=range] { width: 100%; margin: 10px 0; }
        button { font-size: 1.2rem; padding: 15px 30px; border-radius: 30px; border: none; cursor: pointer; margin: 5px; transition: 0.2s; width: 100%; max-width: 300px; }
        #btnStart { background: #007aff; color: white; }
        #btnStop { background: #ff3b30; color: white; display: none; }
        #btnDownload { background: #34c759; color: white; display: none; margin-top: 10px; }
        
        .status { margin-top: 10px; font-weight: bold; color: #888; height: 20px; }
        .recording { color: #ff3b30; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div class="card">
        <div class="label">Temps de nuisance cumulé</div>
        <div id="timer">00:00:00</div>
        <div id="status" class="status">Prêt</div>
    </div>

    <div class="card">
        <div class="label">Réglage Sensibilité</div>
        <canvas id="visualizer"></canvas>
        <input type="range" id="threshold" min="0" max="255" value="50">
        <p style="font-size: 0.8rem; color: #666;">Glissez vers la droite pour ignorer les bruits faibles.</p>
    </div>

    <button id="btnStart" onclick="startApp()">Démarrer l'écoute</button>
    <button id="btnStop" onclick="stopApp()">Arrêter & Sauvegarder</button>
    
    <!-- Lien de téléchargement caché -->
    <a id="downloadLink" style="display:none"></a>

    <script>
        let audioContext, analyser, microphone, mediaRecorder;
        let chunks = [];
        let isRunning = false;
        let isRecordingAudio = false;
        let startTime = 0;
        let accumulatedTime = 0; // en millisecondes
        let silenceTimer = null;
        
        // Paramètres
        const SILENCE_DELAY = 2000; // Attend 2 secondes de silence avant de couper l'enregistrement
        let silenceStart = 0;

        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timer');
        const statusDisplay = document.getElementById('status');
        const thresholdInput = document.getElementById('threshold');

        async function startApp() {
            try {
                // Initialisation Audio
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                // Initialisation Enregistreur
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                
                // Hack pour Safari: On lance, on met en pause immédiatement
                mediaRecorder.start();
                mediaRecorder.pause(); 

                isRunning = true;
                document.getElementById('btnStart').style.display = 'none';
                document.getElementById('btnStop').style.display = 'inline-block';
                statusDisplay.innerText = "En écoute...";

                // Boucle d'analyse
                function analyze() {
                    if (!isRunning) return;
                    requestAnimationFrame(analyze);

                    analyser.getByteFrequencyData(dataArray);

                    // 1. Calculer le volume moyen instantané
                    let sum = 0;
                    for(let i = 0; i < bufferLength; i++) { sum += dataArray[i]; }
                    let average = sum / bufferLength;
                    
                    // Facteur d'amplification visuelle pour le canvas
                    let displayVol = average * 3; 

                    // 2. Dessiner le canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = isRecordingAudio ? '#ff3b30' : '#ddd';
                    let barWidth = (displayVol / 255) * canvas.width;
                    ctx.fillRect(0, 0, barWidth, canvas.height);
                    
                    // Ligne de seuil
                    let thresholdVal = parseInt(thresholdInput.value);
                    let thresholdX = (thresholdVal / 100) * canvas.width; // Approximation visuelle
                    ctx.beginPath();
                    ctx.moveTo(thresholdX, 0);
                    ctx.lineTo(thresholdX, canvas.height);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // 3. Logique de détection
                    // On compare une moyenne amplifiée au seuil
                    if (average > (thresholdVal / 3)) { 
                        // BRUIT DÉTECTÉ
                        silenceStart = 0; // Reset du timer silence

                        if (!isRecordingAudio) {
                            mediaRecorder.resume();
                            isRecordingAudio = true;
                            statusDisplay.innerText = "ABOIEMENT ENREGISTRÉ";
                            statusDisplay.classList.add('recording');
                        }

                        // Ajout au temps total (approximatif, basé sur 60fps)
                        accumulatedTime += 16.6; 
                        updateTimer();

                    } else {
                        // SILENCE
                        if (isRecordingAudio) {
                            if (silenceStart === 0) silenceStart = Date.now();
                            
                            // Si silence depuis plus de X secondes, on met en pause
                            if (Date.now() - silenceStart > SILENCE_DELAY) {
                                mediaRecorder.pause();
                                isRecordingAudio = false;
                                statusDisplay.innerText = "En écoute (Silence)";
                                statusDisplay.classList.remove('recording');
                            }
                        }
                    }
                }
                analyze();

            } catch (err) {
                alert("Erreur micro: " + err);
            }
        }

        function stopApp() {
            isRunning = false;
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { 'type' : 'audio/webm; codecs=opus' }); // iOS enregistre souvent en m4a/mp4 container
                    const audioURL = window.URL.createObjectURL(blob);
                    
                    // Création du lien de téléchargement
                    const a = document.getElementById('downloadLink');
                    a.href = audioURL;
                    a.download = 'aboiements_voisin.webm'; // .webm est standard web, VLC/Audacity le lisent
                    a.style.display = 'block';
                    a.innerText = "Télécharger l'audio (" + formatTime(accumulatedTime) + ")";
                    a.click();
                };
            }
            
            document.getElementById('btnStop').style.display = 'none';
            statusDisplay.innerText = "Terminé.";
        }

        function updateTimer() {
            timerDisplay.innerText = formatTime(accumulatedTime);
        }

        function formatTime(ms) {
            let seconds = Math.floor(ms / 1000);
            let h = Math.floor(seconds / 3600);
            let m = Math.floor((seconds % 3600) / 60);
            let s = seconds % 60;
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }

        function pad(num) { return num.toString().padStart(2, '0'); }
    </script>
</body>
</html>
