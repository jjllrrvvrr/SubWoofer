<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SubWoofer üê∂</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            text-align: center; 
            padding: 20px; 
            background: #000; 
            color: #fff; 
            touch-action: manipulation;
        }
        
        /* Compteur */
        #timer { 
            font-size: 4rem; 
            font-weight: 700; 
            font-variant-numeric: tabular-nums; 
            color: #ff9f0a;
            margin-top: 20px;
        }
        .timer-label { font-size: 0.8rem; color: #666; text-transform: uppercase; margin-bottom: 30px;}

        /* Badges */
        #status-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            text-transform: uppercase;
            background: #333;
            color: #888;
            margin-bottom: 20px;
        }
        .status-rec { background: #ff3b30 !important; color: white !important; box-shadow: 0 0 15px #ff3b30; animation: pulse 1s infinite; }
        .status-wait { background: #30d158 !important; color: black !important; }
        .status-cooldown { background: #ff9f0a !important; color: black !important; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Canvas */
        .vis-container {
            position: relative;
            height: 120px;
            background: #1c1c1e;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #333;
            margin-bottom: 20px;
        }
        canvas { width: 100%; height: 100%; }
        
        /* Ligne de seuil draggable (visuelle seulement ici, contr√¥l√©e par slider) */
        #threshold-line {
            position: absolute;
            left: 0; right: 0;
            height: 2px;
            background-color: #0a84ff;
            top: 80%; /* Valeur par d√©faut */
            pointer-events: none;
            box-shadow: 0 0 5px #0a84ff;
        }

        /* Slider */
        input[type=range] { width: 100%; margin: 15px 0; accent-color: #0a84ff; cursor: pointer; height: 40px;}

        /* Boutons */
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .full-width { grid-column: span 2; }
        
        button { 
            font-size: 1.1rem; 
            padding: 20px; 
            border-radius: 16px; 
            border: none; 
            font-weight: 700; 
            color: white;
            cursor: pointer;
        }
        button:active { opacity: 0.8; transform: scale(0.98); }
        
        .btn-start { background: #30d158; color: #000; }
        .btn-pause { background: #ff9f0a; color: #000; }
        .btn-stop { background: #ff3b30; color: #fff; }
        .hidden { display: none; }

    </style>
</head>
<body>

    <div id="status-badge">Pr√™t</div>
    
    <div id="timer">00:00:00</div>
    <div class="timer-label">Dur√©e cumul√©e des aboiements</div>

    <div class="vis-container">
        <canvas id="visualizer"></canvas>
        <div id="threshold-line"></div>
    </div>

    <div style="text-align:left; color:#888; font-size:0.8rem; margin-bottom:5px;">R√âGLAGE SENSIBILIT√â (Monter = moins sensible)</div>
    <input type="range" id="slider" min="0" max="255" value="50" oninput="updateThresholdUI()">

    <div class="controls">
        <button id="btn-start" class="btn-start full-width" onclick="startApp()">‚ñ∂ D√âMARRER SURVEILLANCE</button>
        
        <button id="btn-pause" class="btn-pause hidden" onclick="togglePause()">‚è∏ PAUSE</button>
        <button id="btn-stop" class="btn-stop hidden" onclick="stopAndDownload()">‚èπ FINIR & T√âL√âCHARGER</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SILENCE_DELAY = 2000; // 2 secondes de s√©curit√© apr√®s le bruit
        
        // --- VARIABLES ---
        let audioCtx, analyser, microphone, mediaRecorder;
        let masterChunks = []; // Tous les petits bouts d'enregistrement
        let currentSegment = []; // Le bout en cours
        
        let isSystemActive = false; // Est-ce que l'app tourne ?
        let isRecording = false; // Est-ce qu'on √©crit dans le fichier ?
        let isPausedManual = false; // Pause utilisateur
        
        let lastNoiseTime = 0;
        let totalDuration = 0; // Dur√©e totale en ms
        let animationId;

        // UI Elements
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const timerEl = document.getElementById('timer');
        const badge = document.getElementById('status-badge');
        const slider = document.getElementById('slider');
        const line = document.getElementById('threshold-line');
        
        // --- INITIALISATION ---
        async function startApp() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                
                microphone = audioCtx.createMediaStreamSource(stream);
                microphone.connect(analyser);

                // Initialisation du Recorder (On le garde pr√™t mais inactif)
                setupRecorder(stream);

                isSystemActive = true;
                updateUI('running');
                loop();

            } catch (e) {
                alert("Erreur Micro: " + e.message);
            }
        }

        // Configuration pour iOS/Android
        function setupRecorder(stream) {
            // iOS pr√©f√®re mp4, Chrome pr√©f√®re webm.
            // Pour pouvoir coller les morceaux, 'video/webm' ou 'audio/webm' est le plus stable
            // Mais sur iOS, on va tenter le mp4 si webm n'est pas dispo.
            let options = { mimeType: 'audio/webm' };
            if (!MediaRecorder.isTypeSupported('audio/webm')) {
                options = { mimeType: 'audio/mp4' }; // Fallback iOS
            }
            
            // On recr√©e une instance √† chaque segment pour √©viter les bugs de concat√©nation
            // Note: On n'instancie pas ici, on le fera √† la vol√©e dans startSegment
            window.globalStream = stream; // Sauvegarde globale pour r√©utilisation
            window.recOptions = options;
        }

        function startSegment() {
            if (isRecording) return;
            
            // Cr√©ation d'un NOUVEAU recorder pour ce segment
            mediaRecorder = new MediaRecorder(window.globalStream, window.recOptions);
            currentSegment = [];
            
            mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) currentSegment.push(e.data);
            };
            
            mediaRecorder.onstop = () => {
                // Quand ce segment est fini, on l'ajoute au master
                const blob = new Blob(currentSegment, { type: window.recOptions.mimeType });
                masterChunks.push(blob);
                console.log("Segment sauvegard√©. Total segments: " + masterChunks.length);
            };

            mediaRecorder.start();
            isRecording = true;
            badge.innerText = "ENREGISTREMENT...";
            badge.className = "status-rec";
        }

        function stopSegment() {
            if (!isRecording) return;
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;
            badge.innerText = "En veille (√âcoute)";
            badge.className = "status-wait";
        }

        // --- BOUCLE PRINCIPALE ---
        function loop() {
            if (!isSystemActive) return;
            animationId = requestAnimationFrame(loop);

            if (isPausedManual) return;

            // 1. Analyse du volume
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            let sum = 0;
            for(let i=0; i<bufferLength; i++) sum += dataArray[i];
            let volume = sum / bufferLength; // Moyenne 0-255

            // 2. Seuil (invers√© graphiquement : haut du slider = bas de l'√©cran)
            let threshold = parseInt(slider.value);
            
            // 3. Dessin
            drawVisualizer(volume, threshold);

            // 4. Logique de d√©cision
            let now = Date.now();

            if (volume > threshold) {
                // BRUIT
                lastNoiseTime = now;
                
                if (!isRecording) {
                    startSegment();
                }

                // Mise √† jour Timer
                totalDuration += 16.66; // ~60fps
                timerEl.innerText = formatTime(totalDuration);
                
            } else {
                // SILENCE
                let timeSinceNoise = now - lastNoiseTime;

                if (timeSinceNoise < SILENCE_DELAY) {
                    // P√©riode tampon (on garde l'enregistrement actif)
                    if (isRecording) {
                        badge.innerText = "Fin d'aboiement...";
                        badge.className = "status-cooldown";
                        totalDuration += 16.66;
                        timerEl.innerText = formatTime(totalDuration);
                    }
                } else {
                    // Vrai silence -> On coupe
                    if (isRecording) {
                        stopSegment();
                    }
                }
            }
        }

        // --- UI & OUTILS ---
        function updateThresholdUI() {
            // Bouge la ligne bleue selon le slider
            let val = parseInt(slider.value);
            let pct = (val / 255) * 100;
            line.style.bottom = pct + "%";
            line.style.top = "auto";
        }

        function drawVisualizer(vol, thresh) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Barre verte ou rouge
            let h = (vol / 255) * canvas.height;
            ctx.fillStyle = vol > thresh ? '#ff3b30' : '#30d158';
            ctx.fillRect(0, canvas.height - h, canvas.width, h);
        }

        function togglePause() {
            isPausedManual = !isPausedManual;
            let btn = document.getElementById('btn-pause');
            
            if (isPausedManual) {
                if (isRecording) stopSegment(); // Coupe si on √©tait en train d'enregistrer
                badge.innerText = "PAUSE MANUELLE";
                badge.className = "";
                btn.innerText = "‚ñ∂ REPRENDRE";
                btn.style.background = "#30d158";
                btn.style.color = "white";
                ctx.clearRect(0,0,canvas.width, canvas.height);
            } else {
                badge.innerText = "En veille";
                badge.className = "status-wait";
                btn.innerText = "‚è∏ PAUSE";
                btn.style.background = "#ff9f0a";
                btn.style.color = "black";
            }
        }

        function stopAndDownload() {
            isSystemActive = false;
            cancelAnimationFrame(animationId);
            if (isRecording) stopSegment();

            setTimeout(() => {
                if (masterChunks.length === 0) {
                    alert("Aucun bruit d√©tect√©, rien √† t√©l√©charger !");
                    location.reload();
                    return;
                }

                // Assemblage final
                const finalBlob = new Blob(masterChunks, { type: window.recOptions.mimeType });
                const url = URL.createObjectURL(finalBlob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = "SubWoofer_Aboyements_" + formatTime(totalDuration).replace(/:/g, '-') + ".mp4"; // Ou .webm selon le support
                document.body.appendChild(a);
                a.click();
                
                badge.innerText = "Sauvegard√© !";
                
                setTimeout(() => {
                    if(confirm("Fichier g√©n√©r√© ! Recommencer ?")) location.reload();
                }, 1000);

            }, 500); // Petit d√©lai pour laisser le temps au dernier stopSegment de finir
        }

        function updateUI(state) {
            if (state === 'running') {
                document.getElementById('btn-start').classList.add('hidden');
                document.getElementById('btn-pause').classList.remove('hidden');
                document.getElementById('btn-stop').classList.remove('hidden');
                document.querySelector('.full-width').classList.remove('full-width');
            }
        }

        function formatTime(ms) {
            let s = Math.floor(ms / 1000);
            let m = Math.floor(s / 60);
            let h = Math.floor(m / 60);
            s = s % 60; m = m % 60;
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }
        function pad(n) { return n.toString().padStart(2, '0'); }
        
        // Init UI position
        updateThresholdUI();

    </script>
</body>
</html>
