<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SubWoofer v9 üê∂</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            text-align: center; 
            padding: 20px; 
            background: #000; 
            color: #fff; 
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Compteur */
        #timer { 
            font-size: 3.5rem; 
            font-weight: 700; 
            font-variant-numeric: tabular-nums; 
            color: #ff9f0a;
            margin-top: 10px;
            text-shadow: 0 0 20px rgba(255, 159, 10, 0.3);
        }
        .timer-label { font-size: 0.75rem; color: #666; text-transform: uppercase; margin-bottom: 20px; letter-spacing: 1px;}

        /* Status Badge */
        #status-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 800;
            text-transform: uppercase;
            background: #2c2c2e;
            color: #888;
            margin-bottom: 15px;
            border: 1px solid #333;
        }
        .status-rec { background: #ff3b30 !important; color: white !important; box-shadow: 0 0 15px #ff3b30; animation: pulse 1s infinite; border-color: #ff3b30 !important;}
        .status-wait { background: #30d158 !important; color: #000 !important; border-color: #30d158 !important;}
        
        @keyframes pulse { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.8; } 100% { transform: scale(1); opacity: 1; } }

        /* Visualizer */
        .vis-container {
            position: relative;
            height: 120px;
            background: #1c1c1e;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid #333;
            margin-bottom: 15px;
            box-shadow: inset 0 0 20px #000;
        }
        canvas { width: 100%; height: 100%; }
        
        #threshold-line {
            position: absolute;
            left: 0; right: 0;
            height: 2px;
            background-color: #0a84ff;
            bottom: 20%; 
            pointer-events: none;
            box-shadow: 0 0 8px #0a84ff;
            z-index: 10;
            transition: bottom 0.1s ease-out;
        }

        /* Settings Card */
        .card {
            background: #1c1c1e;
            padding: 15px;
            border-radius: 16px;
            margin-bottom: 20px;
            border: 1px solid #333;
            text-align: left;
        }
        
        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #333;
        }
        .toggle-label { font-size: 0.9rem; font-weight: 600; }
        .toggle-sub { font-size: 0.7rem; color: #666; display: block; margin-top: 2px; }

        .switch-btn {
            background: #3a3a3c; color: #888; border: none; padding: 8px 16px;
            border-radius: 8px; font-size: 0.8rem; font-weight: bold; cursor: pointer;
            transition: all 0.3s ease;
        }
        .switch-btn.active { background: #0a84ff; color: white; box-shadow: 0 0 10px rgba(10, 132, 255, 0.4); }

        .slider-header { display: flex; justify-content: space-between; font-size: 0.8rem; color: #aaa; margin-bottom: 5px; }
        .slider-value { color: #0a84ff; font-weight: bold; }
        input[type=range] { width: 100%; height: 40px; accent-color: #0a84ff; cursor: pointer; }

        /* Buttons */
        .controls { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
        
        button.main-btn { 
            font-size: 1rem; padding: 18px; border-radius: 14px; border: none; 
            font-weight: 700; color: white; cursor: pointer; text-transform: uppercase;
            transition: transform 0.1s;
        }
        button.main-btn:active { transform: scale(0.96); }
        
        .btn-start { background: #30d158; color: #000; box-shadow: 0 4px 15px rgba(48, 209, 88, 0.3); }
        .btn-stop { background: #ff3b30; color: #fff; }
        .hidden { display: none; }

    </style>
</head>
<body>

    <div id="status-badge">Pr√™t</div>
    
    <div id="timer">00:00:00</div>
    <div class="timer-label">Dur√©e cumul√©e (Exacte)</div>

    <div class="vis-container">
        <canvas id="visualizer"></canvas>
        <div id="threshold-line"></div>
    </div>

    <div class="card">
        <div class="toggle-row">
            <div>
                <span class="toggle-label">üîç Filtre Audio</span>
                <span class="toggle-sub">Ignore bruits sourds & aigus</span>
            </div>
            <button id="btn-filter" class="switch-btn active" onclick="toggleFilter()">ACTIV√â</button>
        </div>

        <div class="slider-header">
            <span>Sensibilit√© (Seuil)</span>
            <span id="slider-val" class="slider-value">20</span>
        </div>
        <input type="range" id="slider" min="5" max="100" value="20" oninput="updateThresholdUI()">
    </div>

    <div class="controls">
        <button id="btn-start" class="main-btn btn-start" onclick="startApp()">‚ñ∂ D√©marrer Surveillance</button>
        <button id="btn-stop" class="main-btn btn-stop hidden" onclick="stopAndSave()">‚èπ Finir et T√©l√©charger</button>
    </div>

    <script>
        // CONFIG
        const SILENCE_DELAY_MS = 1500; // Temps de maintien apr√®s le bruit
        const SAMPLE_RATE = 44100;
        
        // VARS
        let audioCtx, analyser, microphone, scriptProcessor;
        let isRunning = false;
        let isRecording = false;
        let isFilterOn = true;
        let recordedBuffers = []; // On stocke le son ici
        let silenceStart = 0;
        let frameCount = 0;
        
        // UI ELEMENTS
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const timerEl = document.getElementById('timer');
        const badge = document.getElementById('status-badge');
        const slider = document.getElementById('slider');
        const filterBtn = document.getElementById('btn-filter');
        const line = document.getElementById('threshold-line');

        async function startApp() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                
                microphone = audioCtx.createMediaStreamSource(stream);
                
                // Processeur de Script (Capture manuelle du son)
                // BufferSize de 4096 = environ 92ms de son par paquet
                scriptProcessor = audioCtx.createScriptProcessor(4096, 1, 1);

                // Chainage: Micro -> Filtres (si actifs) -> Analyser -> Processor -> Destination
                setupConnections();

                scriptProcessor.onaudioprocess = (e) => {
                    if (!isRunning) return;

                    const inputData = e.inputBuffer.getChannelData(0);
                    const bufferLen = inputData.length;
                    
                    // 1. Analyse du volume sur ce petit paquet de son
                    let sum = 0;
                    for(let i=0; i<bufferLen; i+=10) { // Optimisation: check 1 sample sur 10
                        sum += Math.abs(inputData[i]);
                    }
                    let avg = sum / (bufferLen/10);
                    let volume = avg * 500; // Amplification pour √©chelle 0-100

                    let threshold = parseInt(slider.value);
                    drawVisualizer(volume, threshold);

                    // 2. Logique d'enregistrement "Intelligente"
                    let now = Date.now();

                    if (volume > threshold) {
                        // BRUIT D√âTECT√â
                        isRecording = true;
                        silenceStart = now; // Reset du timer silence
                        badge.innerText = "ENREGISTREMENT...";
                        badge.className = "status-rec";
                    } else {
                        // SILENCE
                        if (isRecording) {
                            if (now - silenceStart > SILENCE_DELAY_MS) {
                                isRecording = false; // Stop
                                badge.innerText = "En veille";
                                badge.className = "status-wait";
                            }
                        }
                    }

                    // 3. Si on doit enregistrer, on garde ce paquet
                    if (isRecording) {
                        // On clone les donn√©es pour les sauvegarder
                        recordedBuffers.push(new Float32Array(inputData));
                        
                        // Mise √† jour Timer (bas√©e sur la quantit√© r√©elle de donn√©es stock√©es)
                        // bufferLen / SAMPLE_RATE = dur√©e en secondes de ce paquet
                        updateTimer();
                    }
                };

                isRunning = true;
                updateUI('running');

            } catch (e) {
                alert("Erreur acc√®s micro : " + e.message);
            }
        }

        function setupConnections() {
            // Reset des connexions
            microphone.disconnect();
            if(analyser) analyser.disconnect();
            if(scriptProcessor) scriptProcessor.disconnect();

            // Cr√©ation filtres dynamiques
            let activeNode = microphone;

            if (isFilterOn) {
                const fHigh = audioCtx.createBiquadFilter();
                fHigh.type = "highpass";
                fHigh.frequency.value = 300;

                const fLow = audioCtx.createBiquadFilter();
                fLow.type = "lowpass";
                fLow.frequency.value = 3000;

                activeNode.connect(fHigh);
                fHigh.connect(fLow);
                activeNode = fLow;
            }

            activeNode.connect(analyser);
            analyser.connect(scriptProcessor);
            scriptProcessor.connect(audioCtx.destination); // N√©cessaire pour que le processeur tourne
        }

        function updateTimer() {
            // Calcul pr√©cis : (Nombre de paquets * taille paquet) / Fr√©quence
            // C'est la dur√©e physique exacte de l'audio stock√©
            let totalSamples = recordedBuffers.length * 4096; 
            let totalMs = (totalSamples / SAMPLE_RATE) * 1000;
            
            let s = Math.floor(totalMs / 1000);
            let m = Math.floor(s / 60);
            let h = Math.floor(m / 60);
            s = s % 60; m = m % 60;
            
            timerEl.innerText = `${pad(h)}:${pad(m)}:${pad(s)}`;
        }

        function stopAndSave() {
            isRunning = false;
            
            if (recordedBuffers.length === 0) {
                alert("Aucun bruit d√©tect√©.");
                location.reload();
                return;
            }

            badge.innerText = "Cr√©ation du fichier...";
            
            setTimeout(() => {
                // 1. Fusionner tous les buffers en un seul
                let totalLen = recordedBuffers.length * 4096;
                let mergedBuffer = new Float32Array(totalLen);
                let offset = 0;
                for (let buf of recordedBuffers) {
                    mergedBuffer.set(buf, offset);
                    offset += buf.length;
                }

                // 2. Encoder en WAV
                let wavBlob = encodeWAV(mergedBuffer, SAMPLE_RATE);
                
                // 3. T√©l√©charger
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                
                let date = new Date();
                let timeStr = `${pad(date.getHours())}h${pad(date.getMinutes())}`;
                let durationStr = timerEl.innerText.replace(/:/g,'-');
                
                a.download = `Chien_${timeStr}_Duree-${durationStr}.wav`;
                
                document.body.appendChild(a);
                a.click();

                badge.innerText = "T√©l√©charg√© !";
                setTimeout(() => { 
                    if(confirm("Fichier sauvegard√©. Voulez-vous recommencer ?")) location.reload(); 
                }, 1000);

            }, 100);
        }

        // --- WAV ENCODER (Vanilla JS) ---
        function encodeWAV(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            // Fonction helper pour √©crire des strings
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');
            // fmt sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, 1, true); // Mono
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            // data sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            // √âcriture des donn√©es audio PCM (Float -> Int16)
            let offset = 44;
            for (let i = 0; i < samples.length; i++) {
                let s = Math.max(-1, Math.min(1, samples[i])); // Clamping
                s = s < 0 ? s * 0x8000 : s * 0x7FFF; // Conversion
                view.setInt16(offset, s, true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        // --- HELPERS ---
        function toggleFilter() {
            isFilterOn = !isFilterOn;
            filterBtn.classList.toggle("active");
            filterBtn.innerText = isFilterOn ? "ACTIV√â" : "D√âSACTIV√â";
            if(audioCtx) setupConnections(); // Reconfigure audio graph
        }

        function updateThresholdUI() {
            let val = parseInt(slider.value);
            document.getElementById('slider-val').innerText = val;
            let pct = (val / 100) * 100; // Echelle adapt√©e au volume
            line.style.bottom = pct + "%";
        }

        function drawVisualizer(vol, thresh) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let barHeight = (vol / 100) * canvas.height; 
            
            if (vol > thresh) ctx.fillStyle = '#ff3b30'; 
            else ctx.fillStyle = '#30d158'; 
            
            ctx.fillRect(0, canvas.height - barHeight, canvas.width, barHeight);
        }

        function updateUI(state) {
            document.getElementById('btn-start').classList.add('hidden');
            document.getElementById('btn-stop').classList.remove('hidden');
        }

        function pad(n) { return n.toString().padStart(2, '0'); }

        updateThresholdUI();
    </script>
</body>
</html>
