<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SubWoofer v10.1 üõ°Ô∏è</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            text-align: center; 
            padding: 20px; 
            background: #000; 
            color: #fff; 
            touch-action: manipulation;
            user-select: none;
            transition: background 0.3s;
        }
        
        /* Mode Discret (Stealth) */
        body.stealth-mode { background: #000; }
        body.stealth-mode > *:not(.stealth-overlay) { display: none !important; }
        .stealth-overlay { 
            display: none; 
            height: 100vh; flex-direction: column; justify-content: center; align-items: center; color: #333;
        }
        body.stealth-mode .stealth-overlay { display: flex; }

        /* Compteur Principal */
        #timer { 
            font-size: 3.5rem; font-weight: 700; color: #ff9f0a; margin-top: 10px; 
            font-variant-numeric: tabular-nums;
        }
        .status-text { font-size: 0.9rem; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 20px;}

        /* Visualiseur */
        .vis-wrapper {
            position: relative; height: 120px; background: #1c1c1e;
            border-radius: 12px; overflow: hidden; border: 1px solid #333; margin-bottom: 20px;
        }
        canvas { width: 100%; height: 100%; }
        #thresh-line {
            position: absolute; left: 0; right: 0; height: 2px;
            background: #0a84ff; bottom: 20%; pointer-events: none; transition: bottom 0.1s;
        }

        /* Contr√¥les */
        .controls-area { margin-top: 20px; }
        
        input[type=range] { width: 100%; height: 40px; accent-color: #0a84ff; margin-bottom: 10px;}
        .range-label { display: flex; justify-content: space-between; color: #aaa; font-size: 0.8rem; margin-bottom: 5px;}

        button { border: none; padding: 15px; border-radius: 12px; font-weight: bold; cursor: pointer; font-size: 1rem; width: 100%; margin-bottom: 10px; text-transform: uppercase;}
        
        .btn-start { background: #30d158; color: #000; }
        .btn-stop { background: #ff3b30; color: #fff; display: none; }
        
        /* Boutons Options */
        .options-row { display: flex; gap: 10px; margin-top: 10px; }
        .btn-opt { background: #333; color: #ccc; font-size: 0.8rem; padding: 10px; }
        
        /* Zone de t√©l√©chargement finale */
        #download-area { display: none; background: #1c1c1e; padding: 20px; border-radius: 12px; border: 1px solid #333; }
        .btn-dl-audio { background: #0a84ff; color: white; margin-bottom: 15px; }
        .btn-dl-txt { background: #333; color: #aaa; font-size: 0.8rem; text-transform: none; }

    </style>
</head>
<body>

    <!-- OVERLAY MODE DISCRET -->
    <div class="stealth-overlay" onclick="toggleStealth()">
        <div style="font-size: 3rem;">üê∂</div>
        <div style="margin-top:20px;">Enregistrement en cours...</div>
        <div style="font-size: 0.7rem; margin-top:30px; border:1px solid #333; padding:5px 15px; border-radius:20px;">Toucher pour rallumer</div>
    </div>

    <!-- INTERFACE PRINCIPALE -->
    <div id="main-ui">
        <div id="status" class="status-text">Pr√™t</div>
        <div id="timer">00:00:00</div>

        <div class="vis-wrapper">
            <canvas id="vis"></canvas>
            <div id="thresh-line"></div>
        </div>

        <div class="range-label">
            <span>Sensibilit√©</span>
            <span id="val-disp" style="color:#0a84ff; font-weight:bold;">20</span>
        </div>
        <input type="range" id="slider" min="5" max="100" value="20" oninput="uiUpdate()">

        <div class="controls-area">
            <button id="btn-start" class="btn-start" onclick="start()">‚ñ∂ D√©marrer</button>
            <button id="btn-stop" class="btn-stop" onclick="stop()">‚èπ Finir & Sauvegarder</button>
            
            <div class="options-row" id="opt-row" style="display:none;">
                <button class="btn-opt" onclick="toggleStealth()">üåô √âcran Noir</button>
            </div>
        </div>
    </div>

    <!-- ZONE T√âL√âCHARGEMENT -->
    <div id="download-area">
        <h3 style="margin-top:0">Session Termin√©e</h3>
        <p style="color:#888; font-size:0.9rem; margin-bottom:20px;">L'audio contient uniquement les bruits d√©tect√©s (+ 2 sec avant chaque bruit).</p>
        
        <button class="btn-dl-audio" onclick="downloadWAV()">üéµ T√©l√©charger l'Audio (.wav)</button>
        <button class="btn-dl-txt" onclick="downloadLog()">üìÑ T√©l√©charger le Rapport √©crit</button>
        <button class="btn-opt" onclick="location.reload()">üîÑ Nouvelle Session</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SAMPLE_RATE = 44100;
        const PRE_ROLL_SEC = 2.0; // 2 secondes de m√©moire tampon
        const SILENCE_DELAY = 2000; // 2 secondes de silence avant de couper
        
        // --- VARIABLES ---
        let audioCtx, mic, analyser, processor;
        let isRunning = false;
        let isRecording = false;
        
        let recordedChunks = [];  // Audio final
        let preRollBuffer = [];   // M√©moire tampon (pass√©)
        let silenceStart = 0;
        
        let eventLogs = [];
        let sessionStart = null;

        // UI Elements
        const canvas = document.getElementById('vis');
        const ctx = canvas.getContext('2d');
        const timerEl = document.getElementById('timer');

        async function start() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                
                mic = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                
                // Processeur Audio (Buffer ~0.09s)
                processor = audioCtx.createScriptProcessor(4096, 1, 1);
                
                mic.connect(analyser);
                analyser.connect(processor);
                processor.connect(audioCtx.destination);
                
                processor.onaudioprocess = processAudio;
                
                isRunning = true;
                sessionStart = new Date();
                
                // UI
                document.getElementById('btn-start').style.display = 'none';
                document.getElementById('btn-stop').style.display = 'block';
                document.getElementById('opt-row').style.display = 'flex';
                document.getElementById('status').innerText = "En √©coute (M√©moire tampon active)";
                document.getElementById('status').style.color = "#30d158";

            } catch (e) { alert("Erreur Micro: " + e); }
        }

        function processAudio(e) {
            if(!isRunning) return;
            
            const input = e.inputBuffer.getChannelData(0);
            const chunk = new Float32Array(input); // Copie des donn√©es
            const threshold = parseInt(document.getElementById('slider').value);
            
            // 1. Analyse du volume
            let sum = 0;
            for(let i=0; i<chunk.length; i+=10) sum += Math.abs(chunk[i]);
            let vol = (sum / (chunk.length/10)) * 500;
            draw(vol, threshold);

            // 2. Gestion du Pre-Roll (On garde les derni√®res secondes en boucle)
            preRollBuffer.push(chunk);
            if(preRollBuffer.length > 25) preRollBuffer.shift(); // ~2.3 sec max

            // 3. D√©tection
            let now = Date.now();
            
            if (vol > threshold) {
                // BRUIT D√âTECT√â
                if (!isRecording) {
                    isRecording = true;
                    document.getElementById('status').innerText = "üî¥ ENREGISTREMENT";
                    document.getElementById('status').style.color = "#ff3b30";
                    
                    // ON R√âCUP√àRE LE PASS√â (Pre-Roll)
                    if(preRollBuffer.length > 0) {
                        recordedChunks.push(...preRollBuffer);
                    }
                    
                    eventLogs.push(`Bruit √† ${new Date().toLocaleTimeString()}`);
                }
                silenceStart = now; // Reset du timer de silence
            } else {
                // SILENCE
                if (isRecording && (now - silenceStart > SILENCE_DELAY)) {
                    isRecording = false;
                    document.getElementById('status').innerText = "En √©coute...";
                    document.getElementById('status').style.color = "#30d158";
                }
            }

            // 4. √âcriture
            if (isRecording) {
                recordedChunks.push(chunk);
                updateTimer();
            }
        }

        function stop() {
            isRunning = false;
            if(audioCtx) audioCtx.close();
            
            document.getElementById('main-ui').style.display = 'none';
            document.getElementById('download-area').style.display = 'block';
        }

        // --- EXPORT ---

        function downloadWAV() {
            if(recordedChunks.length === 0) { alert("Aucun bruit d√©tect√© !"); return; }
            
            // Assemblage du fichier
            let length = recordedChunks.length * 4096;
            let buffer = new Float32Array(length);
            let offset = 0;
            for(let c of recordedChunks) {
                buffer.set(c, offset);
                offset += c.length;
            }
            
            let wav = encodeWAV(buffer);
            let url = URL.createObjectURL(wav);
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `Preuve_Audio_${new Date().getHours()}h${new Date().getMinutes()}.wav`;
            document.body.appendChild(a);
            a.click();
        }

        function downloadLog() {
            let txt = "JOURNAL DE SURVEILLANCE\n";
            txt += "D√©but : " + sessionStart.toLocaleString() + "\n";
            txt += "-------------------------\n";
            txt += eventLogs.join("\n");
            
            let blob = new Blob([txt], {type: 'text/plain'});
            let url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = "Rapport.txt";
            document.body.appendChild(a);
            a.click();
        }

        // Encodage WAV (Standard PCM 16-bit)
        function encodeWAV(samples) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);
            const writeString = (v, o, s) => { for (let i=0; i<s.length; i++) v.setUint8(o+i, s.charCodeAt(i)); };

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
            view.setUint32(24, SAMPLE_RATE, true); view.setUint32(28, SAMPLE_RATE * 2, true);
            view.setUint16(32, 2, true); view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            let offset = 44;
            for (let i = 0; i < samples.length; i++) {
                let s = Math.max(-1, Math.min(1, samples[i]));
                s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                view.setInt16(offset, s, true);
                offset += 2;
            }
            return new Blob([view], { type: 'audio/wav' });
        }

        // --- UI UTILS ---
        function toggleStealth() {
            document.body.classList.toggle('stealth-mode');
        }

        function updateTimer() {
            let totalSeconds = (recordedChunks.length * 4096) / SAMPLE_RATE;
            let h = Math.floor(totalSeconds / 3600);
            let m = Math.floor((totalSeconds % 3600) / 60);
            let s = Math.floor(totalSeconds % 60);
            timerEl.innerText = `${pad(h)}:${pad(m)}:${pad(s)}`;
        }
        
        function draw(vol, thresh) {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            let h = (vol/100) * canvas.height;
            ctx.fillStyle = vol > thresh ? '#ff3b30' : '#30d158';
            ctx.fillRect(0, canvas.height - h, canvas.width, h);
        }

        function uiUpdate() {
            let val = document.getElementById('slider').value;
            document.getElementById('val-disp').innerText = val;
            document.getElementById('thresh-line').style.bottom = val + "%";
        }
        
        function pad(n) { return n.toString().padStart(2,'0'); }
        uiUpdate();
    </script>
</body>
</html>
